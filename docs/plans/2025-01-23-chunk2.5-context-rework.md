# Chunk 2.5: Context & Prompt Rework

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Update context building for structured memory blocks, rich summaries, constellation activity tracking, and system prompt templates.

**Architecture:** New `context_v2` module alongside existing context code, using memory_v2's structured types and MemoryStore trait.

**Important Distinction:**
- **Memory blocks** (Log type): Agent-managed via memory tools, Loro-backed, stored in memory_blocks table
- **Constellation activity**: System-level telemetry, NOT a memory block, stored in activity_events table, not manipulable by agents - USING coordination types in `pattern_db/src/models/coordination.rs`

**Tech Stack:** memory_v2 module (from Chunk 2), pattern_db, Loro documents

**Depends On:** Chunk 2 (memory_v2 with StructuredDocument, BlockSchema)

---

## Philosophy

**DO:**
- Add `context_v2/` module alongside existing context code
- Build schema-aware context rendering
- Create structured SummaryBlock for rich archive summaries
- Implement activity event logging to database
- Create system prompt templates for agents
- Keep old context code untouched

**DON'T:**
- Modify existing context code yet
- Break compilation
- Try to share implementations between old and new

---

## As-Built Reconciliation (2025-12-23)

### Key Finding: memory_v2/context.rs Already Exists

There's already a `MemoryContextBuilder` in `memory_v2/context.rs` that handles basic context building:
- Groups blocks by BlockType (Core, Working, Log)
- XML-like formatting with descriptions
- Excludes Archival blocks
- Token estimation

**Decision:** Keep `context_v2` as a SEPARATE module (not inside memory_v2). This is the correct architecture because:
1. `memory_v2/context.rs` = simple memory block formatting
2. `context_v2/` = full context assembly with model limits, activity, summaries

### API Method Name Correction

The plan references `store.get_block_rendered()` but the actual MemoryStore trait uses:
```rust
async fn get_rendered_content(&self, agent_id: &str, label: &str) -> MemoryResult<Option<String>>
```

**Action:** Use `get_rendered_content()` in builder.rs implementations.

### Database Tables Required

Need to create migration `0005_activity_and_summaries.sql` with:
- `activity_events` table
- `conversation_summaries` table

**NOTE:** The pattern_db queries (activity.rs, summary.rs) referenced in Task 6 don't exist yet - they must be created first.

### Task Status

- Tasks 1-5: Ready to implement as specified
- Task 6: Requires creating pattern_db query modules BEFORE the pattern_core code that uses them

---

## Task 1: Create Context V2 Module Structure

**Files:**
- Create: `crates/pattern_core/src/context_v2/mod.rs`
- Create: `crates/pattern_core/src/context_v2/types.rs`
- Modify: `crates/pattern_core/src/lib.rs`

**Step 1: Create module directory**

```bash
mkdir -p crates/pattern_core/src/context_v2
```

**Step 2: Create types.rs with context types**

```rust
//! Types for v2 context building
//!
//! Supports structured memory blocks, activity logging,
//! and rich summaries.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use crate::memory_v2::{BlockType, BlockSchema};

/// Model-specific context limits
#[derive(Debug, Clone)]
pub struct ModelContextLimits {
    /// Maximum total context tokens for this model
    pub max_tokens: usize,

    /// Maximum tokens for memory section
    pub memory_tokens: usize,

    /// Maximum tokens for message history
    pub history_tokens: usize,

    /// Reserved tokens for response
    pub reserved_response_tokens: usize,
}

impl ModelContextLimits {
    /// Claude Sonnet / large model defaults
    pub fn large() -> Self {
        Self {
            max_tokens: 200_000,
            memory_tokens: 12_000,
            history_tokens: 80_000,
            reserved_response_tokens: 8_000,
        }
    }

    /// Claude Haiku / small model defaults
    pub fn small() -> Self {
        Self {
            max_tokens: 200_000,  // Same window, but we use less
            memory_tokens: 6_000,
            history_tokens: 40_000,
            reserved_response_tokens: 4_000,
        }
    }
}

/// Configuration for context building
#[derive(Debug, Clone)]
pub struct ContextConfig {
    /// Default limits (used when no model-specific override)
    pub default_limits: ModelContextLimits,

    /// Model-specific overrides (model_id -> limits)
    /// Agent's model routing config determines which to use
    pub model_overrides: std::collections::HashMap<String, ModelContextLimits>,

    /// Include block descriptions in context
    pub include_descriptions: bool,

    /// Include block schemas (for tool understanding)
    pub include_schemas: bool,

    /// Number of constellation activity entries to show (system telemetry, not memory)
    pub activity_entries_limit: usize,
}

impl Default for ContextConfig {
    fn default() -> Self {
        Self {
            default_limits: ModelContextLimits::large(),
            model_overrides: std::collections::HashMap::new(),
            include_descriptions: true,
            include_schemas: false,
            activity_entries_limit: 15,
        }
    }
}

impl ContextConfig {
    /// Get limits for a specific model, falling back to defaults
    pub fn limits_for_model(&self, model_id: Option<&str>) -> &ModelContextLimits {
        model_id
            .and_then(|id| self.model_overrides.get(id))
            .unwrap_or(&self.default_limits)
    }
}

// NOTE: Log block display limits are per-block via BlockSchema::Log { display_limit }
// Not configured globally here - each log block controls its own context footprint

/// Activity event types for logging
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ActivityEventType {
    /// Message received from user/integration
    MessageReceived {
        source: String,
        preview: String,
    },

    /// Message sent by agent
    MessageSent {
        preview: String,
    },

    /// Tool was called
    ToolCalled {
        tool: String,
        success: bool,
    },

    /// Memory block was modified
    MemoryModified {
        label: String,
        operation: String,
    },

    /// Archival entry added/searched
    ArchivalOperation {
        operation: String, // "insert", "search", "delete"
        count: usize,
    },

    /// Context was compressed
    ContextCompressed {
        messages_archived: usize,
        summary_created: bool,
    },

    /// Agent heartbeat (continuation)
    Heartbeat,

    /// Custom event
    Custom {
        event_type: String,
        details: String,
    },
}

/// A logged activity event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActivityEvent {
    pub id: String,
    pub agent_id: String,
    pub event_type: ActivityEventType,
    pub timestamp: DateTime<Utc>,
    pub batch_id: Option<String>,
}

/// Structured summary block for archived conversations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SummaryBlock {
    /// Summary text
    pub content: String,

    /// Topics covered in this summary
    pub topics: Vec<String>,

    /// Time range of summarized messages
    pub time_range: TimeRange,

    /// Number of messages summarized
    pub message_count: usize,

    /// Depth level (0 = first summary, 1+ = summary of summaries)
    pub depth: u32,

    /// ID of previous summary in chain (for traversal)
    pub previous_summary_id: Option<String>,

    /// Metadata from summarized content
    pub metadata: SummaryMetadata,
}

/// Time range for summaries
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimeRange {
    pub start: DateTime<Utc>,
    pub end: DateTime<Utc>,
}

/// Metadata extracted during summarization
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SummaryMetadata {
    /// Key decisions made
    pub decisions: Vec<String>,

    /// Important facts learned
    pub facts: Vec<String>,

    /// Tasks mentioned
    pub tasks: Vec<String>,

    /// People/entities mentioned
    pub entities: Vec<String>,
}

impl Default for SummaryMetadata {
    fn default() -> Self {
        Self {
            decisions: vec![],
            facts: vec![],
            tasks: vec![],
            entities: vec![],
        }
    }
}

/// Rendered block for context inclusion
#[derive(Debug, Clone)]
pub struct RenderedBlock {
    /// Block label
    pub label: String,

    /// Block type
    pub block_type: BlockType,

    /// Rendered content
    pub content: String,

    /// Description (if included)
    pub description: Option<String>,

    /// Estimated tokens
    pub estimated_tokens: usize,
}

/// System prompt section types
#[derive(Debug, Clone)]
pub enum SystemPromptSection {
    /// Agent persona and behavior
    Persona(String),

    /// Memory state section
    Memory(Vec<RenderedBlock>),

    /// Tool descriptions
    Tools(Vec<ToolDescription>),

    /// Recent activity summary
    ActivitySummary(String),

    /// Instructions for this interaction
    Instructions(String),
}

/// Tool description for system prompt
#[derive(Debug, Clone)]
pub struct ToolDescription {
    pub name: String,
    pub description: String,
    pub parameters: Vec<ParameterDescription>,
    /// Schema-aware usage examples
    pub examples: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct ParameterDescription {
    pub name: String,
    pub description: String,
    pub required: bool,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = ContextConfig::default();
        let limits = config.limits_for_model(None);
        assert!(limits.max_tokens > 0);
        assert!(limits.memory_tokens < limits.max_tokens);
    }

    #[test]
    fn test_model_specific_limits() {
        let mut config = ContextConfig::default();
        config.model_overrides.insert(
            "haiku".into(),
            ModelContextLimits::small(),
        );

        // Default gets large limits
        let default_limits = config.limits_for_model(None);
        assert_eq!(default_limits.memory_tokens, 12_000);

        // Haiku gets small limits
        let haiku_limits = config.limits_for_model(Some("haiku"));
        assert_eq!(haiku_limits.memory_tokens, 6_000);
    }

    #[test]
    fn test_activity_event_serialization() {
        let event = ActivityEvent {
            id: "evt_1".into(),
            agent_id: "agent_1".into(),
            event_type: ActivityEventType::MessageReceived {
                source: "discord".into(),
                preview: "Hello".into(),
            },
            timestamp: Utc::now(),
            batch_id: None,
        };
        let json = serde_json::to_string(&event).unwrap();
        let _: ActivityEvent = serde_json::from_str(&json).unwrap();
    }
}
```

**Step 3: Create mod.rs**

```rust
//! V2 Context System
//!
//! Schema-aware context building with structured summaries
//! and activity logging.

mod types;

pub use types::*;

// Placeholder for future modules
// mod builder;     // Context builder
// mod activity;    // Activity logging
// mod summary;     // Summary generation
// mod prompt;      // System prompt templates
```

**Step 4: Add to lib.rs**

```rust
pub mod context_v2;
```

**Step 5: Verify compilation**

Run: `cargo check -p pattern_core`
Expected: PASS

**Step 6: Run tests**

Run: `cargo test -p pattern_core context_v2::types`
Expected: PASS

**Step 7: Commit**

```bash
git add crates/pattern_core/src/context_v2/ crates/pattern_core/src/lib.rs
git commit -m "feat(pattern_core): add context_v2 module with types"
```

---

## Task 2: Create Activity Logger

**Files:**
- Create: `crates/pattern_core/src/context_v2/activity.rs`
- Modify: `crates/pattern_core/src/context_v2/mod.rs`

**Step 1: Create activity.rs**

```rust
//! Activity logging for agents
//!
//! Logs agent activity events to the database for:
//! - History tracking
//! - Log block display
//! - Analytics

use crate::db_v2::ConstellationDb;
use crate::context_v2::{ActivityEvent, ActivityEventType};
use chrono::Utc;
use std::sync::Arc;

/// Error type for activity operations
#[derive(Debug, thiserror::Error)]
pub enum ActivityError {
    #[error("Database error: {0}")]
    Database(#[from] pattern_db::DbError),

    #[error("{0}")]
    Other(String),
}

pub type ActivityResult<T> = Result<T, ActivityError>;

/// Activity logger for an agent
pub struct ActivityLogger {
    db: Arc<ConstellationDb>,
    agent_id: String,
}

impl ActivityLogger {
    pub fn new(db: Arc<ConstellationDb>, agent_id: impl Into<String>) -> Self {
        Self {
            db,
            agent_id: agent_id.into(),
        }
    }

    /// Log an activity event
    pub async fn log(&self, event_type: ActivityEventType) -> ActivityResult<String> {
        self.log_with_batch(event_type, None).await
    }

    /// Log an activity event with batch ID
    pub async fn log_with_batch(
        &self,
        event_type: ActivityEventType,
        batch_id: Option<String>,
    ) -> ActivityResult<String> {
        let id = format!("evt_{}", uuid::Uuid::new_v4());

        let event = ActivityEvent {
            id: id.clone(),
            agent_id: self.agent_id.clone(),
            event_type,
            timestamp: Utc::now(),
            batch_id,
        };

        // Store in database
        let event_json = serde_json::to_string(&event.event_type)
            .map_err(|e| ActivityError::Other(e.to_string()))?;

        pattern_db::queries::activity::create_activity_event(
            self.db.pool(),
            &id,
            &self.agent_id,
            &event_json,
            event.batch_id.as_deref(),
        ).await?;

        Ok(id)
    }

    /// Get recent activity events
    pub async fn recent(&self, limit: usize) -> ActivityResult<Vec<ActivityEvent>> {
        let rows = pattern_db::queries::activity::list_activity_events(
            self.db.pool(),
            &self.agent_id,
            limit as i64,
        ).await?;

        rows.into_iter()
            .map(|row| {
                let event_type: ActivityEventType = serde_json::from_str(&row.event_type_json)
                    .unwrap_or(ActivityEventType::Custom {
                        event_type: "unknown".into(),
                        details: row.event_type_json,
                    });

                Ok(ActivityEvent {
                    id: row.id,
                    agent_id: row.agent_id,
                    event_type,
                    timestamp: row.created_at,
                    batch_id: row.batch_id,
                })
            })
            .collect()
    }

    /// Render recent activity as text for context
    pub async fn render_recent(&self, limit: usize) -> ActivityResult<String> {
        let events = self.recent(limit).await?;

        let lines: Vec<String> = events.iter().map(|e| {
            let ts = e.timestamp.format("%Y-%m-%d %H:%M");
            let desc = match &e.event_type {
                ActivityEventType::MessageReceived { source, preview } =>
                    format!("Received message from {}: {}", source, truncate(preview, 40)),
                ActivityEventType::MessageSent { preview } =>
                    format!("Sent message: {}", truncate(preview, 40)),
                ActivityEventType::ToolCalled { tool, success } =>
                    format!("Called {} ({})", tool, if *success { "✓" } else { "✗" }),
                ActivityEventType::MemoryModified { label, operation } =>
                    format!("Memory {}: {}", operation, label),
                ActivityEventType::ArchivalOperation { operation, count } =>
                    format!("Archival {}: {} entries", operation, count),
                ActivityEventType::ContextCompressed { messages_archived, .. } =>
                    format!("Compressed context ({} messages archived)", messages_archived),
                ActivityEventType::Heartbeat =>
                    "Heartbeat".into(),
                ActivityEventType::Custom { event_type, details } =>
                    format!("{}: {}", event_type, truncate(details, 40)),
            };
            format!("[{}] {}", ts, desc)
        }).collect();

        Ok(lines.join("\n"))
    }
}

fn truncate(s: &str, max: usize) -> String {
    if s.len() <= max {
        s.to_string()
    } else {
        format!("{}...", &s[..max-3])
    }
}

/// Convenience functions for common events
impl ActivityLogger {
    pub async fn log_message_received(&self, source: &str, preview: &str) -> ActivityResult<String> {
        self.log(ActivityEventType::MessageReceived {
            source: source.into(),
            preview: preview.into(),
        }).await
    }

    pub async fn log_message_sent(&self, preview: &str) -> ActivityResult<String> {
        self.log(ActivityEventType::MessageSent {
            preview: preview.into(),
        }).await
    }

    pub async fn log_tool_called(&self, tool: &str, success: bool) -> ActivityResult<String> {
        self.log(ActivityEventType::ToolCalled {
            tool: tool.into(),
            success,
        }).await
    }

    pub async fn log_memory_modified(&self, label: &str, operation: &str) -> ActivityResult<String> {
        self.log(ActivityEventType::MemoryModified {
            label: label.into(),
            operation: operation.into(),
        }).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_activity_logger() {
        let dir = tempfile::tempdir().unwrap();
        let db = ConstellationDb::open(dir.path().join("test.db")).await.unwrap();
        let logger = ActivityLogger::new(Arc::new(db), "agent_1");

        // Log some events
        logger.log_message_received("discord", "Hello there!").await.unwrap();
        logger.log_tool_called("context.append", true).await.unwrap();

        // Check recent
        let recent = logger.recent(10).await.unwrap();
        assert_eq!(recent.len(), 2);

        // Render
        let rendered = logger.render_recent(10).await.unwrap();
        assert!(rendered.contains("discord"));
        assert!(rendered.contains("context.append"));
    }
}
```

**Step 2: Add to mod.rs**

```rust
mod activity;
pub use activity::*;
```

**Step 3: Verify compilation**

Run: `cargo check -p pattern_core`
Expected: PASS

**Step 4: Run tests**

Run: `cargo test -p pattern_core context_v2::activity`
Expected: PASS

**Step 5: Commit**

```bash
git add crates/pattern_core/src/context_v2/
git commit -m "feat(pattern_core): add activity logger for agent events"
```

---

## Task 3: Create Summary Generator

**Files:**
- Create: `crates/pattern_core/src/context_v2/summary.rs`
- Modify: `crates/pattern_core/src/context_v2/mod.rs`

**Step 1: Create summary.rs**

```rust
//! Structured summary generation
//!
//! Creates SummaryBlocks with rich metadata from
//! compressed conversations.

use crate::context_v2::{SummaryBlock, SummaryMetadata, TimeRange};
use crate::db_v2::ConstellationDb;
use chrono::{DateTime, Utc};
use std::sync::Arc;

/// Error type for summary operations
#[derive(Debug, thiserror::Error)]
pub enum SummaryError {
    #[error("Database error: {0}")]
    Database(#[from] pattern_db::DbError),

    #[error("{0}")]
    Other(String),
}

pub type SummaryResult<T> = Result<T, SummaryError>;

/// Summary store for persisting and retrieving summaries
pub struct SummaryStore {
    db: Arc<ConstellationDb>,
}

impl SummaryStore {
    pub fn new(db: Arc<ConstellationDb>) -> Self {
        Self { db }
    }

    /// Store a new summary
    pub async fn store(&self, agent_id: &str, summary: &SummaryBlock) -> SummaryResult<String> {
        let id = format!("sum_{}", uuid::Uuid::new_v4());

        let summary_json = serde_json::to_string(summary)
            .map_err(|e| SummaryError::Other(e.to_string()))?;

        pattern_db::queries::summary::create_summary(
            self.db.pool(),
            &id,
            agent_id,
            &summary.content,
            &summary_json,
            summary.depth as i64,
            summary.previous_summary_id.as_deref(),
            summary.time_range.start,
            summary.time_range.end,
            summary.message_count as i64,
        ).await?;

        Ok(id)
    }

    /// Get a summary by ID
    pub async fn get(&self, id: &str) -> SummaryResult<Option<SummaryBlock>> {
        let row = pattern_db::queries::summary::get_summary(self.db.pool(), id).await?;

        row.map(|r| {
            serde_json::from_str(&r.summary_json)
                .map_err(|e| SummaryError::Other(e.to_string()))
        }).transpose()
    }

    /// Get the most recent summary for an agent
    pub async fn get_latest(&self, agent_id: &str) -> SummaryResult<Option<SummaryBlock>> {
        let row = pattern_db::queries::summary::get_latest_summary(self.db.pool(), agent_id).await?;

        row.map(|r| {
            serde_json::from_str(&r.summary_json)
                .map_err(|e| SummaryError::Other(e.to_string()))
        }).transpose()
    }

    /// Get summary chain (traverse previous_summary_id links)
    pub async fn get_chain(&self, start_id: &str, max_depth: usize) -> SummaryResult<Vec<SummaryBlock>> {
        let mut chain = Vec::new();
        let mut current_id = Some(start_id.to_string());

        while let Some(id) = current_id {
            if chain.len() >= max_depth {
                break;
            }

            if let Some(summary) = self.get(&id).await? {
                current_id = summary.previous_summary_id.clone();
                chain.push(summary);
            } else {
                break;
            }
        }

        Ok(chain)
    }
}

/// Builder for creating summaries from messages
pub struct SummaryBuilder {
    content: String,
    topics: Vec<String>,
    time_range: Option<TimeRange>,
    message_count: usize,
    depth: u32,
    previous_summary_id: Option<String>,
    metadata: SummaryMetadata,
}

impl SummaryBuilder {
    pub fn new() -> Self {
        Self {
            content: String::new(),
            topics: vec![],
            time_range: None,
            message_count: 0,
            depth: 0,
            previous_summary_id: None,
            metadata: SummaryMetadata::default(),
        }
    }

    pub fn content(mut self, content: impl Into<String>) -> Self {
        self.content = content.into();
        self
    }

    pub fn topics(mut self, topics: Vec<String>) -> Self {
        self.topics = topics;
        self
    }

    pub fn add_topic(mut self, topic: impl Into<String>) -> Self {
        self.topics.push(topic.into());
        self
    }

    pub fn time_range(mut self, start: DateTime<Utc>, end: DateTime<Utc>) -> Self {
        self.time_range = Some(TimeRange { start, end });
        self
    }

    pub fn message_count(mut self, count: usize) -> Self {
        self.message_count = count;
        self
    }

    pub fn depth(mut self, depth: u32) -> Self {
        self.depth = depth;
        self
    }

    pub fn previous_summary(mut self, id: impl Into<String>) -> Self {
        self.previous_summary_id = Some(id.into());
        self
    }

    pub fn add_decision(mut self, decision: impl Into<String>) -> Self {
        self.metadata.decisions.push(decision.into());
        self
    }

    pub fn add_fact(mut self, fact: impl Into<String>) -> Self {
        self.metadata.facts.push(fact.into());
        self
    }

    pub fn add_task(mut self, task: impl Into<String>) -> Self {
        self.metadata.tasks.push(task.into());
        self
    }

    pub fn add_entity(mut self, entity: impl Into<String>) -> Self {
        self.metadata.entities.push(entity.into());
        self
    }

    pub fn build(self) -> SummaryBlock {
        SummaryBlock {
            content: self.content,
            topics: self.topics,
            time_range: self.time_range.unwrap_or_else(|| TimeRange {
                start: Utc::now(),
                end: Utc::now(),
            }),
            message_count: self.message_count,
            depth: self.depth,
            previous_summary_id: self.previous_summary_id,
            metadata: self.metadata,
        }
    }
}

impl Default for SummaryBuilder {
    fn default() -> Self {
        Self::new()
    }
}

/// Render a summary for inclusion in context
pub fn render_summary(summary: &SummaryBlock) -> String {
    let mut lines = vec![
        format!("## Summary (depth {}, {} messages)", summary.depth, summary.message_count),
        format!("**Period:** {} to {}",
            summary.time_range.start.format("%Y-%m-%d %H:%M"),
            summary.time_range.end.format("%Y-%m-%d %H:%M")),
    ];

    if !summary.topics.is_empty() {
        lines.push(format!("**Topics:** {}", summary.topics.join(", ")));
    }

    lines.push(String::new());
    lines.push(summary.content.clone());

    // Include key metadata
    if !summary.metadata.decisions.is_empty() {
        lines.push(String::new());
        lines.push("**Key decisions:**".into());
        for d in &summary.metadata.decisions {
            lines.push(format!("- {}", d));
        }
    }

    if !summary.metadata.facts.is_empty() {
        lines.push(String::new());
        lines.push("**Facts learned:**".into());
        for f in &summary.metadata.facts {
            lines.push(format!("- {}", f));
        }
    }

    lines.join("\n")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_summary_builder() {
        let summary = SummaryBuilder::new()
            .content("Had a productive conversation about memory systems.")
            .topics(vec!["memory".into(), "architecture".into()])
            .message_count(15)
            .depth(0)
            .add_decision("Use Loro CRDT for versioning")
            .add_fact("User prefers concise responses")
            .build();

        assert_eq!(summary.message_count, 15);
        assert_eq!(summary.depth, 0);
        assert_eq!(summary.metadata.decisions.len(), 1);
    }

    #[test]
    fn test_render_summary() {
        let summary = SummaryBuilder::new()
            .content("Discussion about refactoring.")
            .topics(vec!["refactoring".into()])
            .message_count(10)
            .add_decision("Split into chunks")
            .build();

        let rendered = render_summary(&summary);
        assert!(rendered.contains("Summary"));
        assert!(rendered.contains("10 messages"));
        assert!(rendered.contains("Split into chunks"));
    }
}
```

**Step 2: Add to mod.rs**

```rust
mod summary;
pub use summary::*;
```

**Step 3: Verify and test**

Run: `cargo check -p pattern_core && cargo test -p pattern_core context_v2::summary`
Expected: PASS

**Step 4: Commit**

```bash
git add crates/pattern_core/src/context_v2/
git commit -m "feat(pattern_core): add structured summary system"
```

---

## Task 4: Create Context Builder

**Files:**
- Create: `crates/pattern_core/src/context_v2/builder.rs`
- Modify: `crates/pattern_core/src/context_v2/mod.rs`

**Step 1: Create builder.rs**

```rust
//! Context builder for LLM calls
//!
//! Assembles memory blocks, activity logs, and summaries
//! into context for the model, respecting schemas and limits.

use crate::memory_v2::{MemoryStore, BlockType, BlockSchema};
use crate::context_v2::{
    ContextConfig, RenderedBlock, ActivityLogger, SummaryStore,
    render_summary,
};
use std::sync::Arc;

/// Error type for context building
#[derive(Debug, thiserror::Error)]
pub enum ContextError {
    #[error("Memory error: {0}")]
    Memory(#[from] crate::memory_v2::MemoryError),

    #[error("Activity error: {0}")]
    Activity(#[from] crate::context_v2::ActivityError),

    #[error("Summary error: {0}")]
    Summary(#[from] crate::context_v2::SummaryError),

    #[error("{0}")]
    Other(String),
}

pub type ContextResult<T> = Result<T, ContextError>;

/// Built context ready for LLM
pub struct BuiltContext {
    /// Memory section
    pub memory: String,

    /// Recent activity section (if included)
    pub activity: Option<String>,

    /// Summary section (if archive summaries exist)
    pub summary: Option<String>,

    /// Total estimated tokens
    pub estimated_tokens: usize,

    /// Individual rendered blocks
    pub blocks: Vec<RenderedBlock>,
}

/// Schema-aware context builder
pub struct ContextBuilder<S: MemoryStore> {
    store: Arc<S>,
    config: ContextConfig,
    agent_id: String,
    /// Target model for this context build (affects token limits)
    target_model: Option<String>,
    activity_logger: Option<ActivityLogger>,
    summary_store: Option<Arc<SummaryStore>>,
}

impl<S: MemoryStore> ContextBuilder<S> {
    pub fn new(store: Arc<S>, agent_id: impl Into<String>) -> Self {
        Self {
            store,
            config: ContextConfig::default(),
            agent_id: agent_id.into(),
            target_model: None,
            activity_logger: None,
            summary_store: None,
        }
    }

    pub fn with_config(mut self, config: ContextConfig) -> Self {
        self.config = config;
        self
    }

    /// Set target model for model-specific limits
    /// This should match the agent's current model routing choice
    pub fn with_target_model(mut self, model_id: impl Into<String>) -> Self {
        self.target_model = Some(model_id.into());
        self
    }

    pub fn with_activity_logger(mut self, logger: ActivityLogger) -> Self {
        self.activity_logger = Some(logger);
        self
    }

    pub fn with_summary_store(mut self, store: Arc<SummaryStore>) -> Self {
        self.summary_store = Some(store);
        self
    }

    /// Build the full context
    pub async fn build(&self) -> ContextResult<BuiltContext> {
        let mut blocks = Vec::new();
        let mut memory_parts = Vec::new();
        let mut total_tokens = 0;

        // Get model-specific limits
        let limits = self.config.limits_for_model(self.target_model.as_deref());

        // Get all blocks for agent
        let all_blocks = self.store.list_blocks(&self.agent_id).await?;

        // Render Core blocks (always included)
        let core_blocks: Vec<_> = all_blocks.iter()
            .filter(|b| b.block_type == BlockType::Core)
            .collect();

        if !core_blocks.is_empty() {
            memory_parts.push("## Core Memory\n".to_string());
            for meta in core_blocks {
                if let Some(rendered) = self.render_block(meta).await? {
                    total_tokens += rendered.estimated_tokens;
                    memory_parts.push(self.format_block(&rendered));
                    blocks.push(rendered);
                }
            }
        }

        // Render Working blocks
        let working_blocks: Vec<_> = all_blocks.iter()
            .filter(|b| b.block_type == BlockType::Working)
            .collect();

        if !working_blocks.is_empty() && total_tokens < limits.memory_tokens {
            memory_parts.push("\n## Working Memory\n".to_string());
            for meta in working_blocks {
                if total_tokens >= limits.memory_tokens {
                    break;
                }
                if let Some(rendered) = self.render_block(meta).await? {
                    total_tokens += rendered.estimated_tokens;
                    memory_parts.push(self.format_block(&rendered));
                    blocks.push(rendered);
                }
            }
        }

        // Render Log blocks (display_limit is per-block via BlockSchema::Log)
        let log_blocks: Vec<_> = all_blocks.iter()
            .filter(|b| b.block_type == BlockType::Log)
            .collect();

        if !log_blocks.is_empty() && total_tokens < limits.memory_tokens {
            memory_parts.push("\n## Recent Logs\n".to_string());
            for meta in log_blocks {
                if total_tokens >= limits.memory_tokens {
                    break;
                }
                if let Some(rendered) = self.render_log_block(meta).await? {
                    total_tokens += rendered.estimated_tokens;
                    memory_parts.push(self.format_block(&rendered));
                    blocks.push(rendered);
                }
            }
        }

        // Get activity if logger provided
        let activity = if let Some(logger) = &self.activity_logger {
            let rendered = logger.render_recent(self.config.activity_entries_limit).await?;
            if !rendered.is_empty() {
                Some(rendered)
            } else {
                None
            }
        } else {
            None
        };

        // Get latest summary if store provided
        let summary = if let Some(store) = &self.summary_store {
            store.get_latest(&self.agent_id).await?
                .map(|s| render_summary(&s))
        } else {
            None
        };

        Ok(BuiltContext {
            memory: memory_parts.join("\n"),
            activity,
            summary,
            estimated_tokens: total_tokens,
            blocks,
        })
    }

    /// Render a single block respecting schema
    async fn render_block(&self, meta: &crate::memory_v2::BlockMetadata) -> ContextResult<Option<RenderedBlock>> {
        let content = self.store.get_block_rendered(&self.agent_id, &meta.label).await?;

        content.map(|c| {
            let tokens = estimate_tokens(&c);
            Ok(RenderedBlock {
                label: meta.label.clone(),
                block_type: meta.block_type,
                content: c,
                description: if self.config.include_descriptions {
                    Some(meta.description.clone())
                } else {
                    None
                },
                estimated_tokens: tokens,
            })
        }).transpose()
    }

    /// Render a log block with entry limit
    async fn render_log_block(&self, meta: &crate::memory_v2::BlockMetadata) -> ContextResult<Option<RenderedBlock>> {
        // For log blocks, we want to limit entries shown in context
        // The StructuredDocument.render() already handles this via schema's display_limit
        // but we can apply additional limits here if needed
        self.render_block(meta).await
    }

    /// Format a rendered block for context
    fn format_block(&self, block: &RenderedBlock) -> String {
        let mut parts = Vec::new();

        parts.push(format!("<{}>", block.label));

        if let Some(desc) = &block.description {
            parts.push(format!("<!-- {} -->", desc));
        }

        parts.push(block.content.clone());
        parts.push(format!("</{}>", block.label));

        parts.join("\n") + "\n"
    }
}

/// Estimate token count (rough heuristic)
fn estimate_tokens(text: &str) -> usize {
    // Rough estimate: ~4 characters per token for English
    text.len() / 4
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::memory_v2::{SqliteMemoryStore, BlockType};
    use crate::db_v2::ConstellationDb;

    async fn test_context() -> (Arc<SqliteMemoryStore>, ContextBuilder<SqliteMemoryStore>) {
        let dir = tempfile::tempdir().unwrap();
        let db = Arc::new(ConstellationDb::open(dir.path().join("test.db")).await.unwrap());
        let store = Arc::new(SqliteMemoryStore::new(db));
        let builder = ContextBuilder::new(store.clone(), "agent_1");
        (store, builder)
    }

    #[tokio::test]
    async fn test_build_context() {
        let (store, builder) = test_context().await;

        // Create some blocks
        store.create_block(
            "agent_1",
            "persona",
            "Agent personality",
            BlockType::Core,
            None,
            "I am a helpful assistant.",
            5000,
        ).await.unwrap();

        store.create_block(
            "agent_1",
            "scratchpad",
            "Working notes",
            BlockType::Working,
            None,
            "Current task: testing",
            5000,
        ).await.unwrap();

        let context = builder.build().await.unwrap();

        assert!(context.memory.contains("<persona>"));
        assert!(context.memory.contains("helpful assistant"));
        assert!(context.memory.contains("<scratchpad>"));
        assert!(context.blocks.len() >= 2);
    }
}
```

**Step 2: Add to mod.rs**

```rust
mod builder;
pub use builder::*;
```

**Step 3: Verify and test**

Run: `cargo check -p pattern_core && cargo test -p pattern_core context_v2::builder`
Expected: PASS

**Step 4: Commit**

```bash
git add crates/pattern_core/src/context_v2/
git commit -m "feat(pattern_core): add schema-aware context builder"
```

---

## Task 5: Create System Prompt Templates

**Files:**
- Create: `crates/pattern_core/src/context_v2/prompt.rs`
- Modify: `crates/pattern_core/src/context_v2/mod.rs`

**Step 1: Create prompt.rs**

```rust
//! System prompt templates for agents
//!
//! Generates system prompts that include memory state,
//! tool descriptions, and schema-aware instructions.

use crate::memory_v2::{BlockSchema, BlockType};
use crate::context_v2::{BuiltContext, ToolDescription};

/// System prompt builder
pub struct SystemPromptBuilder {
    /// Base persona text
    persona: Option<String>,

    /// Memory context
    memory_context: Option<String>,

    /// Activity summary
    activity_summary: Option<String>,

    /// Archive summary
    archive_summary: Option<String>,

    /// Tool descriptions
    tools: Vec<ToolDescription>,

    /// Additional instructions
    instructions: Vec<String>,

    /// Schema information for tools
    schema_hints: Vec<String>,
}

impl SystemPromptBuilder {
    pub fn new() -> Self {
        Self {
            persona: None,
            memory_context: None,
            activity_summary: None,
            archive_summary: None,
            tools: vec![],
            instructions: vec![],
            schema_hints: vec![],
        }
    }

    pub fn persona(mut self, persona: impl Into<String>) -> Self {
        self.persona = Some(persona.into());
        self
    }

    pub fn from_context(mut self, context: &BuiltContext) -> Self {
        self.memory_context = Some(context.memory.clone());
        self.activity_summary = context.activity.clone();
        self.archive_summary = context.summary.clone();
        self
    }

    pub fn add_tool(mut self, tool: ToolDescription) -> Self {
        self.tools.push(tool);
        self
    }

    pub fn add_instruction(mut self, instruction: impl Into<String>) -> Self {
        self.instructions.push(instruction.into());
        self
    }

    /// Add schema hints for structured blocks
    pub fn add_schema_hint(mut self, label: &str, schema: &BlockSchema) -> Self {
        let hint = match schema {
            BlockSchema::Text => {
                format!("The '{}' block accepts free-form text. Use context.append to add content.", label)
            }
            BlockSchema::Map { fields } => {
                let field_names: Vec<_> = fields.iter().map(|f| f.name.as_str()).collect();
                format!(
                    "The '{}' block is structured with fields: {}. Use context.set_field to update specific fields.",
                    label,
                    field_names.join(", ")
                )
            }
            BlockSchema::List { .. } => {
                format!(
                    "The '{}' block is a list. Use context.append_to_list to add items, context.remove_from_list to remove.",
                    label
                )
            }
            BlockSchema::Log { display_limit, .. } => {
                format!(
                    "The '{}' block is an agent-managed log showing the last {} entries in context. Full history kept for search.",
                    label, display_limit
                )
            }
            BlockSchema::Tree { .. } => {
                format!("The '{}' block is a hierarchical tree structure.", label)
            }
            BlockSchema::Composite { .. } => {
                format!("The '{}' block has multiple sections.", label)
            }
        };
        self.schema_hints.push(hint);
        self
    }

    pub fn build(self) -> String {
        let mut sections = Vec::new();

        // Persona section
        if let Some(persona) = self.persona {
            sections.push(format!("# Persona\n\n{}", persona));
        }

        // Memory section
        if let Some(memory) = self.memory_context {
            sections.push(format!("# Memory State\n\n{}", memory));
        }

        // Schema hints
        if !self.schema_hints.is_empty() {
            sections.push(format!(
                "# Memory Block Types\n\n{}",
                self.schema_hints.join("\n")
            ));
        }

        // Archive summary
        if let Some(summary) = self.archive_summary {
            sections.push(format!("# Previous Conversation Summary\n\n{}", summary));
        }

        // Activity summary
        if let Some(activity) = self.activity_summary {
            sections.push(format!("# Recent Activity\n\n```\n{}\n```", activity));
        }

        // Tools section
        if !self.tools.is_empty() {
            let mut tool_section = String::from("# Available Tools\n\n");
            for tool in &self.tools {
                tool_section.push_str(&format!("## {}\n\n{}\n\n", tool.name, tool.description));
                if !tool.parameters.is_empty() {
                    tool_section.push_str("**Parameters:**\n");
                    for param in &tool.parameters {
                        let req = if param.required { " (required)" } else { "" };
                        tool_section.push_str(&format!("- `{}`: {}{}\n", param.name, param.description, req));
                    }
                    tool_section.push('\n');
                }
                if !tool.examples.is_empty() {
                    tool_section.push_str("**Examples:**\n");
                    for ex in &tool.examples {
                        tool_section.push_str(&format!("- {}\n", ex));
                    }
                    tool_section.push('\n');
                }
            }
            sections.push(tool_section);
        }

        // Additional instructions
        if !self.instructions.is_empty() {
            sections.push(format!(
                "# Instructions\n\n{}",
                self.instructions.join("\n")
            ));
        }

        sections.join("\n\n---\n\n")
    }
}

impl Default for SystemPromptBuilder {
    fn default() -> Self {
        Self::new()
    }
}

/// Create standard context tool description with schema awareness
pub fn context_tool_description() -> ToolDescription {
    ToolDescription {
        name: "context".into(),
        description: "Manage your working memory. Use to store observations, update human profile, track tasks, etc.".into(),
        parameters: vec![
            ParameterDescription {
                name: "operation".into(),
                description: "append, replace, set_field, append_to_list, remove_from_list, increment_counter".into(),
                required: true,
            },
            ParameterDescription {
                name: "label".into(),
                description: "Block label (persona, human, scratchpad, etc.)".into(),
                required: true,
            },
            ParameterDescription {
                name: "content/field/value".into(),
                description: "Depends on operation".into(),
                required: true,
            },
        ],
        examples: vec![
            "append(label=\"scratchpad\", content=\"Note: user prefers morning meetings\")".into(),
            "set_field(label=\"human\", field=\"name\", value=\"Alice\")".into(),
            "append_to_list(label=\"human\", field=\"preferences\", item=\"Likes tea\")".into(),
            "increment_counter(label=\"human\", field=\"energy_level\", delta=-1)".into(),
        ],
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_system_prompt_builder() {
        let prompt = SystemPromptBuilder::new()
            .persona("I am a helpful AI assistant.")
            .add_instruction("Always be concise.")
            .add_tool(context_tool_description())
            .build();

        assert!(prompt.contains("Persona"));
        assert!(prompt.contains("helpful AI assistant"));
        assert!(prompt.contains("Available Tools"));
        assert!(prompt.contains("context"));
    }

    #[test]
    fn test_schema_hints() {
        let prompt = SystemPromptBuilder::new()
            .add_schema_hint("human", &BlockSchema::Map { fields: vec![] })
            .add_schema_hint("tasks", &BlockSchema::List { item_schema: None, max_items: None })
            .build();

        assert!(prompt.contains("set_field"));
        assert!(prompt.contains("append_to_list"));
    }
}
```

**Step 2: Add to mod.rs**

```rust
mod prompt;
pub use prompt::*;
```

**Step 3: Verify and test**

Run: `cargo check -p pattern_core && cargo test -p pattern_core context_v2::prompt`
Expected: PASS

**Step 4: Commit**

```bash
git add crates/pattern_core/src/context_v2/
git commit -m "feat(pattern_core): add system prompt templates with schema awareness"
```

---

## Task 6: Add pattern_db Queries for Activity and Summaries

**Files:**
- Modify: `crates/pattern_db/src/queries/mod.rs`
- Create: `crates/pattern_db/src/queries/activity.rs`
- Create: `crates/pattern_db/src/queries/summary.rs`

This task adds the database queries needed by the activity logger and summary store.

**Step 1: Add activity queries**

Create `activity.rs`:
```rust
//! Activity event queries

use sqlx::{Pool, Sqlite};
use chrono::{DateTime, Utc};

#[derive(Debug, sqlx::FromRow)]
pub struct ActivityEventRow {
    pub id: String,
    pub agent_id: String,
    pub event_type_json: String,
    pub batch_id: Option<String>,
    pub created_at: DateTime<Utc>,
}

pub async fn create_activity_event(
    pool: &Pool<Sqlite>,
    id: &str,
    agent_id: &str,
    event_type_json: &str,
    batch_id: Option<&str>,
) -> Result<(), crate::DbError> {
    sqlx::query(
        "INSERT INTO activity_events (id, agent_id, event_type_json, batch_id, created_at)
         VALUES (?, ?, ?, ?, ?)"
    )
    .bind(id)
    .bind(agent_id)
    .bind(event_type_json)
    .bind(batch_id)
    .bind(Utc::now())
    .execute(pool)
    .await?;
    Ok(())
}

pub async fn list_activity_events(
    pool: &Pool<Sqlite>,
    agent_id: &str,
    limit: i64,
) -> Result<Vec<ActivityEventRow>, crate::DbError> {
    let rows = sqlx::query_as::<_, ActivityEventRow>(
        "SELECT id, agent_id, event_type_json, batch_id, created_at
         FROM activity_events
         WHERE agent_id = ?
         ORDER BY created_at DESC
         LIMIT ?"
    )
    .bind(agent_id)
    .bind(limit)
    .fetch_all(pool)
    .await?;
    Ok(rows)
}
```

**Step 2: Add summary queries**

Create `summary.rs`:
```rust
//! Summary storage queries

use sqlx::{Pool, Sqlite};
use chrono::{DateTime, Utc};

#[derive(Debug, sqlx::FromRow)]
pub struct SummaryRow {
    pub id: String,
    pub agent_id: String,
    pub content: String,
    pub summary_json: String,
    pub depth: i64,
    pub previous_summary_id: Option<String>,
    pub time_range_start: DateTime<Utc>,
    pub time_range_end: DateTime<Utc>,
    pub message_count: i64,
    pub created_at: DateTime<Utc>,
}

pub async fn create_summary(
    pool: &Pool<Sqlite>,
    id: &str,
    agent_id: &str,
    content: &str,
    summary_json: &str,
    depth: i64,
    previous_summary_id: Option<&str>,
    time_range_start: DateTime<Utc>,
    time_range_end: DateTime<Utc>,
    message_count: i64,
) -> Result<(), crate::DbError> {
    sqlx::query(
        "INSERT INTO conversation_summaries
         (id, agent_id, content, summary_json, depth, previous_summary_id,
          time_range_start, time_range_end, message_count, created_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
    )
    .bind(id)
    .bind(agent_id)
    .bind(content)
    .bind(summary_json)
    .bind(depth)
    .bind(previous_summary_id)
    .bind(time_range_start)
    .bind(time_range_end)
    .bind(message_count)
    .bind(Utc::now())
    .execute(pool)
    .await?;
    Ok(())
}

pub async fn get_summary(
    pool: &Pool<Sqlite>,
    id: &str,
) -> Result<Option<SummaryRow>, crate::DbError> {
    let row = sqlx::query_as::<_, SummaryRow>(
        "SELECT * FROM conversation_summaries WHERE id = ?"
    )
    .bind(id)
    .fetch_optional(pool)
    .await?;
    Ok(row)
}

pub async fn get_latest_summary(
    pool: &Pool<Sqlite>,
    agent_id: &str,
) -> Result<Option<SummaryRow>, crate::DbError> {
    let row = sqlx::query_as::<_, SummaryRow>(
        "SELECT * FROM conversation_summaries
         WHERE agent_id = ?
         ORDER BY created_at DESC
         LIMIT 1"
    )
    .bind(agent_id)
    .fetch_optional(pool)
    .await?;
    Ok(row)
}
```

**Step 3: Add migrations for new tables**

The tables `activity_events` and `conversation_summaries` need to exist. Add migration if not present.

**Step 4: Commit**

```bash
git add crates/pattern_db/src/queries/
git commit -m "feat(pattern_db): add activity and summary queries"
```

---

## Chunk 2.5 Completion Checklist

- [ ] `context_v2/types.rs` with ContextConfig, ActivityEvent, SummaryBlock
- [ ] `context_v2/activity.rs` with ActivityLogger
- [ ] `context_v2/summary.rs` with SummaryStore, SummaryBuilder
- [ ] `context_v2/builder.rs` with schema-aware ContextBuilder
- [ ] `context_v2/prompt.rs` with SystemPromptBuilder
- [ ] pattern_db queries for activity and summaries
- [ ] Migrations for activity_events and conversation_summaries tables
- [ ] All tests pass
- [ ] Old context code untouched and still compiles

---

## Notes for Chunk 3

With context_v2 in place, Chunk 3 (Agent Rework) can:
- Use ContextBuilder for generating LLM context
- Inject ActivityLogger for event tracking
- Use SystemPromptBuilder for agent prompts
- Leverage SummaryStore for archive compression
- All schema-aware operations work seamlessly
