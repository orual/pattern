use crate::messages::{ChatRole, ContentBlock, ContentPart, Message, MessageContent};
use genai::{ModelIden, chat::Usage};
use serde::{Deserialize, Serialize};
use serde_json::json;

/// A response generated by an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Request {
    pub system: Option<Vec<String>>,
    pub messages: Vec<Message>,
    pub tools: Option<Vec<genai::chat::Tool>>,
}

impl Request {
    /// Convert this request to a genai ChatRequest
    pub fn as_chat_request(&mut self) -> crate::Result<genai::chat::ChatRequest> {
        // Fix assistant messages that end with thinking blocks
        for msg in &mut self.messages {
            if msg.role == ChatRole::User || msg.role == ChatRole::System {
                if let MessageContent::Text(text) = &msg.content {
                    use chrono::TimeZone;
                    let time_zone = chrono::Local::now().timezone();
                    let timestamp = time_zone.from_utc_datetime(&msg.created_at.naive_utc());
                    // injecting created time in to make agents less likely to be confused by artifacts and more temporally aware.
                    msg.content = MessageContent::Text(format!(
                        "<time_sync>created: {}</time_sync>\n{}",
                        timestamp, text
                    ));
                }
            } else if msg.role == ChatRole::Assistant {
                if let MessageContent::Blocks(blocks) = &mut msg.content {
                    if let Some(last_block) = blocks.last() {
                        // Check if the last block is a thinking block
                        let ends_with_thinking = matches!(
                            last_block,
                            ContentBlock::Thinking { .. } | ContentBlock::RedactedThinking { .. }
                        );

                        if ends_with_thinking {
                            // Append a minimal text block to fix the issue
                            tracing::debug!(
                                "Appending text block after thinking block in assistant message"
                            );
                            blocks.push(ContentBlock::Text {
                                text: ".".to_string(), // Single period to satisfy non-empty requirement
                                thought_signature: None,
                            });
                        }
                    }
                }
            }
        }

        let messages: Vec<_> = self
            .messages
            .iter()
            .filter(|m| Message::estimate_word_count(&m.content) > 0)
            .map(|m| m.as_chat_message())
            .collect();

        Ok(
            genai::chat::ChatRequest::from_system(self.system.clone().unwrap().join("\n\n"))
                .append_messages(messages)
                .with_tools(self.tools.clone().unwrap_or_default()),
        )
    }
}

/// A response generated by an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response {
    pub content: Vec<MessageContent>,
    pub reasoning: Option<String>,
    pub metadata: ResponseMetadata,
}

impl Response {
    /// Create a Response from a genai ChatResponse
    pub fn from_chat_response(resp: genai::chat::ChatResponse) -> Self {
        // Extract data before consuming resp
        let reasoning = resp.reasoning_content.clone();
        let metadata = ResponseMetadata {
            processing_time: None,
            tokens_used: Some(resp.usage.clone()),
            model_used: Some(resp.provider_model_iden.to_string()),
            confidence: None,
            model_iden: resp.model_iden.clone(),
            custom: resp.captured_raw_body.clone().unwrap_or_default(),
        };

        // Convert genai MessageContent to our MessageContent
        let content: Vec<MessageContent> = resp
            .content
            .clone()
            .into_iter()
            .map(|gc| gc.into())
            .collect();

        Self {
            content,
            reasoning,
            metadata,
        }
    }

    pub fn num_tool_calls(&self) -> usize {
        self.content
            .iter()
            .filter(|c| c.tool_calls().is_some())
            .count()
    }

    pub fn num_tool_responses(&self) -> usize {
        self.content
            .iter()
            .filter(|c| match c {
                MessageContent::ToolResponses(_) => true,
                _ => false,
            })
            .count()
    }

    pub fn has_unpaired_tool_calls(&self) -> bool {
        // Collect all tool call IDs
        let mut tool_calls: Vec<String> = Vec::new();

        // Get tool calls from ToolCalls content
        for content in &self.content {
            if let MessageContent::ToolCalls(calls) = content {
                for call in calls {
                    tool_calls.push(call.call_id.clone());
                }
            }
        }

        // Get tool calls from Blocks
        for content in &self.content {
            if let MessageContent::Blocks(blocks) = content {
                for block in blocks {
                    if let ContentBlock::ToolUse { id, .. } = block {
                        tool_calls.push(id.clone());
                    }
                }
            }
        }

        // If no tool calls, we're done
        if tool_calls.is_empty() {
            return false;
        }

        // Check if we have Anthropic-style IDs (start with "toolu_")
        let has_anthropic_ids = tool_calls.iter().any(|id| id.starts_with("toolu_"));

        if has_anthropic_ids {
            // Anthropic IDs are unique - use set difference
            let tool_call_set: std::collections::HashSet<String> = tool_calls.into_iter().collect();

            let mut tool_response_set: std::collections::HashSet<String> =
                std::collections::HashSet::new();

            // Get tool responses from ToolResponses content
            for content in &self.content {
                if let MessageContent::ToolResponses(responses) = content {
                    for response in responses {
                        tool_response_set.insert(response.call_id.clone());
                    }
                }
            }

            // Get tool responses from Blocks
            for content in &self.content {
                if let MessageContent::Blocks(blocks) = content {
                    for block in blocks {
                        if let ContentBlock::ToolResult { tool_use_id, .. } = block {
                            tool_response_set.insert(tool_use_id.clone());
                        }
                    }
                }
            }

            // Check if there are any tool calls without responses
            tool_call_set.difference(&tool_response_set).count() > 0
        } else {
            // Gemini/other IDs may not be unique - count occurrences
            use std::collections::HashMap;
            let mut call_counts: HashMap<String, usize> = HashMap::new();

            // Count tool calls
            for id in tool_calls {
                *call_counts.entry(id).or_insert(0) += 1;
            }

            // Subtract tool responses
            for content in &self.content {
                if let MessageContent::ToolResponses(responses) = content {
                    for response in responses {
                        if let Some(count) = call_counts.get_mut(&response.call_id) {
                            *count = count.saturating_sub(1);
                        }
                    }
                }
            }

            // Subtract tool responses from Blocks
            for content in &self.content {
                if let MessageContent::Blocks(blocks) = content {
                    for block in blocks {
                        if let ContentBlock::ToolResult { tool_use_id, .. } = block {
                            if let Some(count) = call_counts.get_mut(tool_use_id) {
                                *count = count.saturating_sub(1);
                            }
                        }
                    }
                }
            }

            // Check if any tool calls remain unpaired
            call_counts.values().any(|&count| count > 0)
        }
    }

    pub fn only_text(&self) -> String {
        let mut text = String::new();
        for content in &self.content {
            match content {
                MessageContent::Text(txt) => text.push_str(txt),
                MessageContent::Parts(content_parts) => {
                    for part in content_parts {
                        match part {
                            ContentPart::Text(txt) => text.push_str(txt),
                            ContentPart::Image { .. } => {}
                        }
                        text.push('\n');
                    }
                }
                MessageContent::ToolCalls(_) => {}
                MessageContent::ToolResponses(_) => {}
                MessageContent::Blocks(_) => {}
            }
            text.push('\n');
        }
        text
    }
}

/// Metadata for a response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseMetadata {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub processing_time: Option<chrono::Duration>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tokens_used: Option<Usage>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model_used: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confidence: Option<f32>,
    pub model_iden: ModelIden,
    pub custom: serde_json::Value,
}

impl Default for ResponseMetadata {
    fn default() -> Self {
        Self {
            processing_time: None,
            tokens_used: None,
            model_used: None,
            confidence: None,
            custom: json!({}),
            model_iden: ModelIden::new(genai::adapter::AdapterKind::Ollama, "default_model"),
        }
    }
}
